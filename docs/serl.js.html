<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: serl.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: serl.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module
 *  @name Serl
 *  @summary Currently the only source file.
 *
 *  @description 
 *  'export class/function' chosen over an (export default) expression for explicitness:
 *
 *  @todo Check each METHOD... should it be .STATIC or #INSTANCE? 
 *
 *  @todo Proxy the 'console' object so that we can toggle debug levels
 *
 *  @todo serl.js should be serl.mjs - but the lousy dev server doesn't serve the right
 *  mime type 
 *
 *  @todo https://docsify.js.org/#/quickstart ?
 */

'use strict'

/**
 *  @class module:Serl.Node
 *
 *  @classdesc
 *  Constructor for objects analogous to an [OTP node]{@link
 *  https://erlang.org/doc/reference_manual/distributed.html#nodes}.
 *
 *  @param {string} given Following OTP convention, a [node name]{@link
 *  https://erlang.org/doc/reference_manual/distributed.html#nodes}, 
 *  names should be 'given@host'.
 *
 *  @property {module:Serl.Node#host} host Should mirror OTP convention, presumably refer
 *  to a hostfile.
 *
 *  @property {module:Serl.Node#name} name Analogous to an OTP [node name]{@link
 *  https://erlang.org/doc/reference_manual/distributed.html#nodes}
 *
 *  @property {Map} procMap A map of this node's processes.
 *
 *  @property {Map} nodeMap A map of connected nodes.
 *
 *  @todo Distributed Erlang functionality (we don't need this yet) 
 *  https://erlang.org/doc/reference_manual/distributed.html
 *
 *  @property cookie todo/unimplemented
 *  @property hidden todo/unimplemented
 */
export class Node {

    constructor (given) {

        /** 
        *   @name module:Serl.Node#host 
        *   @type {string}
        *   @todo Assign from a hostfile.
        *   
        */
        this.host   =   'placeholderHost'

        /** 
        *   @name module:Serl.Node#name 
        *   @type {string}
        *   @todo In OTP convention, this depends on -name vs -sname flags
        *   @description Has the form &lt;code>given@host&lt;/code>, which is based on
        *   the given-name of each call to &lt;code>Node(given)&lt;/code>.
        *   
        */
        this.name   =   `${given}@${this.host}`   

        /** 
        *   @name module:Serl.Node#procMap 
        *   @package
        *   @description Keys are Pid instances, Values are Proc instances
        *   @prop {integer} counter This helps us avoid duplicate process-indices on the
        *   local node, when generating a Pid object.
        *
        *   Making this un-writable would be safer, but more expensive as the
        *   value would have to BE RE-CONFIGURED for mutation; and we expect this
        *   to change frequently.
        *
        *   @todo Currently this stores the actual processes as values. Whereas
        *   Pids are keys... so what should the value be, when a Pid key points
        *   to a remote node?
        *
        *   @todo Should this have its own class? Yes if you want JSDoc to be
        *   able to document it structurally. Currently naming its prop to
        *   module:Serl.Node#procMap#counter doesn't register...
        */
        this.procMap    =   new Map( [ ] )  
        Object.defineProperty ( this.procMap, 'counter', {  value : 0,
                                                            writable: true } )

        /** 
        *   @name module:Serl.Node#nodeMap 
        *   @package
        *   @description Keys are integers, Values are { name: 'a string' }
        *
        *   Discuss: not using an Array, because we follow Erlang convention of
        *            limiting the number of connected nodes in a lifetime; so
        *            keys are the nodeIndex
        *   
        *   Here we impose a convention where the local node is index=0
        *
        *   @todo Currently this stores names which can be used to locate
        *   distributed nodes. 
        *
        *   @todo Should this have its own class? Yes if you want JSDoc to be
        *   able to document it structurally. 
        */
        this.nodeMap    =   new Map(    [   [0, { name:this.name }] ] )
    }

    /**
     *  @method module:Serl.Node.nodeIndexFromNodeName
     *  @description 
     *  Utility function, returning a &lt;code>nodeIndex&lt;/code>, integers used as
     *  keys in {@link module:Serl.Node#nodeMap}.
     *  
     *  @param {module:Serl.Node} node An instance of the Node class.
     *  @param {module:Serl.Node#name} nodeName
     *  @returns {integer}
     */
    static nodeIndexFromNodeName (node, nodeName) {
        return Array.from( node.nodeMap.keys() )
                    .find( (key) => node.nodeMap.get(key).name == nodeName )
    }


    /**
     *  @method module:Serl.Node#spawn
     *  @description Implements various arities of spawn/n.
     *  Spawns an instance of [Proc]{@link module:Serl.Proc} on some a certain
     *  instance of [Node]{@link module:Serl.Node}. The keyword
     *  &lt;code>this&lt;/code> in any &lt;code>fun&lt;/code> passed to spawn/n will refer
     *  to the spawned &lt;code>proc&lt;/code>.
     *
     *  &lt;h5>spawn/1&lt;/h5>
     *  Spawns a Proc object on the parent node, which applies
     *  &lt;code>fun&lt;/code> to an empty array &lt;code>[]&lt;/code>. See
     *  &lt;a target="_blank" href="http://erlang.org/doc/man/erlang.html#spawn-1">OTP docs&lt;/a>.
     *  &lt;h6>Parameters:&lt;/h6>
     *
     *  | Name  | Type | Description |
     *  |-------|------|-------------|
     *  | fun | function |The function which will run in this process. 
     *
     *  &lt;h5>spawn/2&lt;/h5>
     *  (coming soon)
     *
     *  &lt;h5>spawn/3&lt;/h5>
     *  Spawns a Proc object on the parent node, which applies a function (given and
     *  accessed via a module) to a list of arguments, in the manner of:
     *  &lt;code>module[funName]( ... funArgs )&lt;/code> See 
     *  &lt;a target="_blank" href="http://erlang.org/doc/man/erlang.html#spawn-3">OTP docs&lt;/a>.
     *  &lt;h6>Parameters:&lt;/h6>
     *
     *  | Name  | Type | Description |
     *  |-------|------|-------------|
     *  | module | object | An object representing a code Module, with callable methods.
     *  | funName | string | The string name of a method of &lt;code>module&lt;/code>. 
     *  | funArgs | array | An array of arguments to pass to &lt;code>module[funName]&lt;/code> when the latter is called.
     *
     *  &lt;h5>spawn/4&lt;/h5>
     *  (coming soon)
     *
     *  @todo implement the 'undefined function' error
     *  @todo refer to 'dynamic module loading' and module objects later 
     *  @todo When &lt;code>fun&lt;/code> returns, Proc should exit formally.
     *
     */

    spawn () {
        let nodeName, procIndex, newProc, module, fun, funArgs
        switch (arguments.length) {
            case 0:
                throw Error( 'Node.spawn/0 called; no implementation.' )
                break

            case 1:

                if ( typeof arguments[0] != 'function' ) { 
                    throw Error( 'Node.spawn/1 called with a non-function' ) 
                }

                nodeName    = this.name
                procIndex   = ++this.procMap.counter
                fun         = arguments[0]

                newProc     = new Proc ( nodeName, procIndex, this )
                newProc.fun = fun

                this.procMap.set ( newProc.pid, newProc )
                newProc.fun([])
                break

            case 2:
                throw Error( 'Node.spawn/2 called; no implementation.' )
                break
            case 3:
                //  http://erlang.org/doc/man/erlang.html#spawn-3

                if ( typeof arguments[0] != 'object' ) { 
                    throw Error( `Node.spawn/3, arguments[0] called with a
                        non-object (expecting the module-object)` ) 
                }

                if ( typeof arguments[1] != 'string' ) { 
                    throw Error( `Node.spawn/3, arguments[1] called with a
                        non-string (expecting the method name as a string` ) 
                }

                if ( ! Array.isArray( arguments[2] ) ) { 
                    throw Error( `Node.spawn/3, arguments[2] called with a
                        non-array (expecting arguments for fun as an array)` ) 
                }

                nodeName        = this.name
                procIndex       = ++this.procMap.counter
                module          = arguments[0]
                fun             = module[arguments[1]]
                funArgs    = arguments[2]

                newProc     = new Proc ( nodeName, procIndex, this )
                newProc.fun = fun

                this.procMap.set ( newProc.pid, newProc )
                newProc.fun ( ... funArgs )
                break
            case 4:
                throw Error( 'Node.spawn/4 called; no implementation.' )
                break
            case 5:
                throw Error( 'Node.spawn/5 called; no implementation.' )
                break
            default:
                throw Error( 'Node.spawn/(>5) called; no implementation.' )
        }

        return newProc.pid

    } // method Node.spawn

} // class Node

/**
 *  @class module:Serl.Proc
 *
 *  @classdesc
 *  Constructor for objects analogous to an [OTP process]{@link
 *  https://erlang.org/doc/getting_started/conc_prog.html#processes}.
 *
 *  @param {module:Serl.Node#name} nodeName
 *
 *  @param {integer} procIndex The internal object
 *  {module:Serl.Node#procMap.counter} is tracked by {module:Serl.Node#spawn},
 *  and its integer value is the construction of each {module.Serl.Pid}.
 *
 *  @param {module:Serl.Node} localNode The instance of {module:Serl.Node} which
 *  spawns the new proc, then stores it in its {module:Serl.Node#procMap}. That
 *  procMap should be the ONLY direct reference to the process, otherwise
 *  interactions with this process should only occur via send/receive i.e.
 *  message-passing.
 *
 *  Utility function, returning a &lt;code>nodeIndex&lt;/code>, integers used as
 *  keys in {@link module:Serl.Node#nodeMap}.
 *
 *  @todo Dependence on localNode is questionable; review.
 *
 *  @todo Do we need to validate argument types here?
 *
 *  @todo Would performance improve if these were static methods? 
 *
 *
 *
 *
 *
 *
 */
export class Proc {

    constructor (nodeName, procIndex, localNode) {
        /**
        *   @name module:Serl.Proc#node
        *   @type {module:Serl.Node}
        *   @todo Review, do we want this here?
        */
        this.node           = localNode 
        this.nodeIndex      = Node.nodeIndexFromNodeName ( localNode, nodeName)
        this.pid            = new Pid (this.nodeIndex, procIndex)
        this.mailbox        = []
        this.mailHandler    = this.defaultMailHandler
    }

    /**
     *  @method module:Serl.Proc#toString
     *  @description 
     *  todo 
     *  
     */
    toString () {
        return `[object Proc&lt;${this.pid.nodeIndex}.${this.pid.procIndex}>]`
    }

    /**
     *  @method module:Serl.Proc#defaultMailHandler 
     *  @description 
     *  todo 
     *  
     */
    defaultMailHandler ( msg ) {
        //console.log( `    defaultMailHandler received a message` )
        this.mailbox.push ( msg )
            // When the next messages come in, they
            // will be held in this.mailbox in their
            // order of arrival. No attempt is made
            // to match them to any further logical
            // branches.
    }

    /**
     *  @method module:Serl.Proc#send 
     *  @description 
     *  todo 
     *  
     */
    send ( dest, msg ) {
        // TODO: we need to validate all first parameter arguments

        switch (arguments.length) {
            case 0:
                throw Error( 'Proc.send/0 called; no implementation.' )
                break
            case 1:
                throw Error( 'Proc.send/1 called; no implementation.' )
                break
            case 2:
                if ( ! ( dest instanceof Pid ) ) {
                    throw Error (`Proc.send/2 called, first argument was not an
                        instance of Pid`)
                }
                //console.log(`    ${this}.send/2: supposed to send a message to ${dest}`)
                this.node.procMap.get ( dest ).mailHandler ( msg )
                 
                break
            default:
                throw Error( 'Proc.send/>2 called; no implementation.' )
                break
        }

    }

    /**
     *  @method module:Serl.Proc#receive 
     *  @description 
     *  todo 
     *  
     */
    receive ( branches ) {

        // TODO: rename 'mailHandler' to mailman?

        // TODO:    typecheck 'branches'? Should be iterable. Currently expects
        //          type: [ [ 'function', 'function'] ]
        //
        //          Perhaps allow type: [ 'function', 'function' ] ?
        //          Perhaps allow type: 'function' where this is just the branch?

        //console.log (`NEWS, ${this}.RECEIVE(): called`)

        let prom = new Promise ( (resolve, reject) => {

                // console.log (`NEWS, promiseExec(): called`)
                this.mailHandler = m => {

                    this.mailbox.push ( m )
                        //  New messages are not always evaluated first.

                    //  Oldest messages are always evaluated first.
                    let messageMatched  =   false
                    let messageIndex    =   0
                    check_entire_mailbox: for ( const msg of this.mailbox ) {
                        match_message_to_reaction: for ( const b of branches ) {

                            // Essential framework conventions
                            let match   = b[0]
                            let branch  = b[1]

                            if ( match ( msg ) ) {
                                //console.log (`    customised mailHandler() MATCHED a message`)

                                messageMatched = true
                                this.mailbox.splice ( messageIndex, 1 )

                                this.mailHandler = this.defaultMailHandler
                                    // This must be done before resolve() so that
                                    // control is passed back to the proc's fn
                                    // body only after the proc.mailHandler has been
                                    // modified to perform safekeeping.

                                let returnedByBranch = branch ( msg )
                                
                                //console.log(
                                //`    returnedByBranch: [[${returnedByBranch}]],
                                //typeof ${typeof returnedByBranch}`)

                                resolve (returnedByBranch)
                                    // Promise Resolved
                                
                                break check_entire_mailbox
                            }
                            //console.log (`    customised mailHandler() tried to match a
                            //    message; failed`)
                        }
                        messageIndex ++ 
                    }
                }
                // if you call proc.receive( x ),   OK
                // then x will be pushed
                // into proc.mailbox,               OK
                // and proc.receive will
                // resolve its promise that is being awaited in proc's
                // function body... and the logic in proc's function
                // body will proceed...             OK 
                
                if ( this.mailbox.length ) {
                    this.mailHandler ( this.mailbox.pop() )
                }
                // this.mailHandler has now been customised, if there are any
                // messages in the mailbox, pop the last one, m, then call
                // this.mailHandler on it... ( which pushes m in at the top of
                // the stack, then starts checking through messages from the
                // bottom of the stack for matches in the mailHandler logic.)
                // TODO: review - really not sure if this is a performance leak.
        } )

        //console.log (`NEWS, RECEIVE(): will now return... `)
        return prom
    }
        /*  Text:           https://erlangbyexample.org/send-receive
            Illustrated:    https://learnyousomeerlang.com/more-on-multiprocessing
        
        How does a process handle received messages?

        When a process receives a message, the message is
        appended to the mailbox.

        The receive block will try each message in the mailbox (one
        by one), against that block's sequence of patterns, until
        one of the messages matches a pattern.

        When there is match, the message gets removed from
        the mailbox and the logic corresponding to the matched pattern
        will get executed. If there is no match,
        then that message remains in the mailbox, and the following
        message gets tried sequentially,
        against all of the receive block's patterns.

        If no messages in the mailbox match any pattern, the process,
        having tried all messages, and having exhausted all receive
        patterns, will get suspended until a new message arrives,
        and the message processing logic starts all over,
        beginning with the first message in the mailbox.

        */
} 
    // TODO: 'registered processes'
    

/**
 *  @class module:Serl.Pid
 *  @classdesc
 *  Constructor for objects analogous to an OTP Pid term.
 */
export class Pid {

    constructor (nodeIndex, procIndex) {
        // TODO: do we need to validate argument types here?
        this.nodeIndex  = nodeIndex
        this.procIndex  = procIndex
    }

    /**
     *  @method module:Serl.Pid#toString
     *  @description 
     *  todo 
     *  
     */
    toString () {
        return `[object Pid&lt;${this.nodeIndex}.${this.procIndex}>]`
    }
} 

/**
 *  @function module:Serl.recurse
 *  @description Utility function that helps reduce boilerplate in spawn/n for
 *  recursing functions. 
 */
export function recurse ( fun, funArgs ){
    // 'function' in expression needed, for 'this' in body

    let utilRecursive =   async ( _fun, _funArgs ) => { 
        // 'async' in expression needed, for 'await' in body

        let utilRecursiveAwaited    =   await _fun.apply ( this, _funArgs ) 
            // value of 'this' is inherited from surrounding scope;
            //
            // So, if 'recurse' is spawn/n-ed on a new Proc, then the context is
            // proc.recurse, and so 'this' would point to 'proc'. (see the
            // source for Node.spawn/n

        // TODO: utilRecursiveAwaited's return value is not used, but 
        // it could be used to replace the default _funArgs

        utilRecursive ( _fun, _funArgs ) 
    } 
    utilRecursive ( fun, funArgs ) 
} 
// TODO: make 'recurse' work with all arities of spawn/n


// TODO: export class Reference ()
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Serl.html">Serl</a></li></ul><h3>Classes</h3><ul><li><a href="module-Serl.Node.html">Node</a></li><li><a href="module-Serl.Pid.html">Pid</a></li><li><a href="module-Serl.Proc.html">Proc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Dec 27 2019 06:51:40 GMT+0800 (Malaysia Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
